USE CASINO;

-- View Everything


-- 1. Number of Hours Each Employee Works per Week--
DROP PROCEDURE IF EXISTS NUM_EMP_WEEK_HOURS;
GO
CREATE PROCEDURE NUM_EMP_WEEK_HOURS
	@StartDate DATE,
	@EndDate DATE
AS
BEGIN
	SELECT SCHEDULE.EMP_ID, SUM(
		CASE WHEN DATEDIFF(HOUR, SHIFT.SHIFT_START, SHIFT.SHIFT_END) < 0
		THEN (DATEDIFF(HOUR, SHIFT.SHIFT_START, SHIFT.SHIFT_END) + 24)
		ELSE DATEDIFF(HOUR, SHIFT.SHIFT_START, SHIFT.SHIFT_END)
		END) as "Number of Hours"
	FROM SCHEDULE
	JOIN SHIFT ON SCHEDULE.SCH_ID = SHIFT.SCH_ID
	JOIN EMPLOYEE ON SCHEDULE.EMP_ID = EMPLOYEE.EMP_ID
	WHERE SCHEDULE.SCH_DATE BETWEEN @StartDate AND @EndDate 
	GROUP BY SCHEDULE.EMP_ID;
END;
GO

EXEC NUM_EMP_WEEK_HOURS '2023-03-31', '2023-04-02';
GO


-- 2. Number of labour hours last week --
DROP PROCEDURE IF EXISTS NUM_LABOUR_HOURS;
GO

CREATE PROCEDURE NUM_LABOUR_HOURS
	@StartDate DATE,
	@EndDate DATE
AS
BEGIN
	SELECT SUM(
		CASE WHEN DATEDIFF(HOUR, SHIFT.SHIFT_START, SHIFT.SHIFT_END) < 0
		THEN (DATEDIFF(HOUR, SHIFT.SHIFT_START, SHIFT.SHIFT_END) + 24)
		ELSE DATEDIFF(HOUR, SHIFT.SHIFT_START, SHIFT.SHIFT_END)
	END) as "Number of Labour Hours"
	FROM SCHEDULE
	JOIN SHIFT ON SCHEDULE.SCH_ID = SHIFT.SCH_ID
	WHERE SCHEDULE.SCH_DATE BETWEEN @StartDate AND @EndDate
END;
GO

EXEC NUM_LABOUR_HOURS '2023-03-31', '2023-04-02';
GO


-- 3. List of Employees that worked in breaker shifts last month --
DROP PROCEDURE IF EXISTS EMP_BREAKER_SHIFTS_WORKED;
GO
CREATE PROCEDURE EMP_BREAKER_SHIFTS_WORKED
	@StartDate DATE,
	@EndDate DATE
AS
BEGIN
	SELECT SCHEDULE.EMP_ID
	FROM SCHEDULE
	JOIN SHIFT ON SCHEDULE.SCH_ID = SHIFT.SCH_ID
	JOIN EMPLOYEE ON SCHEDULE.EMP_ID = EMPLOYEE.EMP_ID
	WHERE SCHEDULE.SCH_DATE BETWEEN @StartDate AND @EndDate AND SHIFT.IS_BREAKER = 1
END;
GO

EXEC EMP_BREAKER_SHIFTS_WORKED '2023-03-31', '2023-04-02';


-- 4. How many breaker shifts are scheduled this week --
DROP PROCEDURE IF EXISTS NUM_BREAKER_SHIFTS;
GO
CREATE PROCEDURE NUM_BREAKER_SHIFTS
	@StartDate DATE,
	@EndDate DATE
AS
BEGIN
	SELECT COUNT(SHIFT.IS_BREAKER) AS "Number of Breaker Shifts"
	FROM SCHEDULE
	JOIN SHIFT ON SCHEDULE.SCH_ID = SHIFT.SCH_ID
	WHERE SCHEDULE.SCH_DATE BETWEEN @StartDate AND @EndDate AND SHIFT.IS_BREAKER = 1
END;
GO

EXEC NUM_BREAKER_SHIFTS '2023-03-31', '2023-04-02';


-- 5. How many slot attendants are scheduled today --
DROP PROCEDURE IF EXISTS NUM_ATTENDENTS_SCHEDULED;
GO
CREATE PROCEDURE NUM_ATTENDENTS_SCHEDULED
	@DATE_SCHEDULED DATE
AS
BEGIN
	SELECT COUNT(SCHEDULE.EMP_ID) as "Number of Attendants Scheduled"
	FROM SCHEDULE
	JOIN EMPLOYEE ON SCHEDULE.EMP_ID = EMPLOYEE.EMP_ID
	WHERE SCHEDULE.SCH_DATE = @DATE_SCHEDULED
END;
GO

EXEC NUM_ATTENDENTS_SCHEDULED '2023-04-02';
GO


-- 6. Any slot attendants not assigned to Section NORTH in last month --
DROP PROCEDURE IF EXISTS GET_UNASSIGNED_ATTENDANT 
GO

CREATE PROCEDURE GET_UNASSIGNED_ATTENDANTS 
	@SectionName NVARCHAR(50)
AS
BEGIN
    WITH LastMonthAttendants AS (
        SELECT DISTINCT SCHEDULE.EMP_ID
        FROM SCHEDULE
        JOIN SHIFT ON SCHEDULE.SCH_ID = SHIFT.SCH_ID
        JOIN SECTION ON SHIFT.SEC_ID = SECTION.SEC_ID
        WHERE SCH_DATE >= DATEADD(month, -1, CURRENT_TIMESTAMP) AND SECTION.SEC_NAME = @SectionName
    )
    SELECT DISTINCT Employee.EMP_ID, CONCAT(EMP_FNAME, ' ', EMP_LNAME) AS EMP_NAME, ROLE_TITLE,
           @SectionName AS NOT_ASSIGNED_SECTION
    FROM EMPLOYEE
    JOIN ROLE ON EMP_ROLE_ID = ROLE_ID
    WHERE ROLE_TITLE LIKE 'SLOT ATTENDANT' AND Employee.EMP_ID NOT IN (SELECT EMP_ID FROM LastMonthAttendants)
END;
GO

EXEC GET_UNASSIGNED_ATTENDANTS NORTH;
GO


-- 7. Number of active Written Warning (WW) employee A has --
DROP PROCEDURE IF EXISTS EMP_WW_COUNT;
GO

CREATE PROCEDURE EMP_WW_COUNT
	@EMP_FNAME VARCHAR(30)
AS
BEGIN
	SELECT EMPLOYEE.EMP_ID, @EMP_FNAME as EMP_FNAME, COUNT(WW_ID) AS ACTIVE_WARNING_COUNT 
	FROM WRITTEN_WARNING 
	JOIN EMPLOYEE 
	ON WRITTEN_WARNING.EMP_ID = EMPLOYEE.EMP_ID
	WHERE WW_LEVEL > 0 AND EMP_FNAME LIKE @EMP_FNAME
	GROUP BY EMPLOYEE.EMP_ID
END
GO

EXEC EMP_WW_COUNT 'A';
GO


-- 8. List of active WW sorted by date and employee --
DROP PROCEDURE IF EXISTS GET_ACTIVE_WRITTEN_WARNINGS;
GO

CREATE PROCEDURE GET_ACTIVE_WRITTEN_WARNINGS
	AS
	BEGIN
		SELECT * FROM WRITTEN_WARNING WHERE WW_LEVEL > 0 ORDER BY WW_DATE_ISSUED, EMP_ID
	END
GO

EXEC GET_ACTIVE_WRITTEN_WARNINGS;
GO


-- 9. List of employee's discipline/performance actions --
DROP PROCEDURE IF EXISTS GET_EMP_PERFORMANCE_REPORT
GO

CREATE PROCEDURE GET_EMP_PERFORMANCE_REPORT
		@EMP_ID INT
	AS
	BEGIN
		WITH CombinedRecords AS (
		  SELECT 
			EMP_ID,
			'Achievement' AS Record_Type,
			ACH_DATE AS Date_Issued,
			ACH_TITLE AS Title,
			ACH_DESC AS Description,
			SUPERVISOR_ID AS Issuer_ID
		  FROM ACHIEVEMENT

		  UNION ALL

		  SELECT 
			EMP_ID,
			'Written Warning' AS Record_Type,
			WW_DATE_ISSUED AS Date_Issued,
			CONCAT('Warning Level ', WW_LEVEL) AS Title,
			WW_DESC AS Description,
			WW_MANAGER_ID AS Issuer_ID
		  FROM WRITTEN_WARNING
		)

		SELECT * FROM CombinedRecords WHERE EMP_ID = @EMP_ID;
	END
GO

EXEC GET_EMP_PERFORMANCE_REPORT 7


-- 10. Number of sick days an employee has available
DROP PROCEDURE IF EXISTS GET_REMAINING_SICK_DAYS;
GO

CREATE PROCEDURE GET_REMAINING_SICK_DAYS
    @EMP_ID INT
AS
BEGIN
    SELECT EMPLOYEE.EMP_ID, EMP_SICK_ENTITLEMENT, EMP_SICK_ENTITLEMENT - SUM(CASE WHEN LEAVE_REASON LIKE 'sick' AND LEAVE.EMP_ID = @EMP_ID THEN DATEDIFF(day, LEAVE_START_DATE, LEAVE_END_DATE) + 1 ELSE 0 END) AS REMAINING_SICK_DAYS
    FROM EMPLOYEE
    LEFT JOIN LEAVE
    ON EMPLOYEE.EMP_ID = LEAVE.EMP_ID
    WHERE EMPLOYEE.EMP_ID = @EMP_ID
    GROUP BY EMPLOYEE.EMP_ID, EMP_SICK_ENTITLEMENT
END
GO

EXEC GET_REMAINING_SICK_DAYS 6;
GO

-- 11. Number of vacation days an employee has available --
DROP PROCEDURE IF EXISTS GET_REMAINING_VACA_DAYS;
GO
CREATE PROCEDURE GET_REMAINING_VACA_DAYS
    @EMP_ID INT
AS
BEGIN
    SELECT EMPLOYEE.EMP_ID, EMP_VACA_ENTITLEMENT, EMP_VACA_ENTITLEMENT - SUM(CASE WHEN LEAVE_REASON LIKE 'vacation' AND LEAVE.EMP_ID = @EMP_ID THEN DATEDIFF(day, LEAVE_START_DATE, LEAVE_END_DATE) + 1 ELSE 0 END) AS REMAINING_VACA_DAYS
    FROM EMPLOYEE
    LEFT JOIN LEAVE
    ON EMPLOYEE.EMP_ID = LEAVE.EMP_ID
    WHERE EMPLOYEE.EMP_ID = @EMP_ID
    GROUP BY EMPLOYEE.EMP_ID, EMP_VACA_ENTITLEMENT
END
GO
EXEC GET_REMAINING_VACA_DAYS 6;


-- Employee Stats: # of M/F, Average age, # of employees over 50 & under 30
DROP PROCEDURE IF EXISTS EMP_STATS;
GO
CREATE PROCEDURE EMP_STATS
	@OverAge INTEGER,
	@UnderAge INTEGER
AS
BEGIN
    SELECT 
        COUNT(CASE WHEN EMP_GENDER = 'M' THEN 1 END) AS [NumberOfMaleEmployees],
        COUNT(CASE WHEN EMP_GENDER = 'F' THEN 1 END) AS [NumberOfFemaleEmployees],
        AVG(DATEDIFF(year, EMP_DOB, GETDATE())) AS [AverageAge],
        COUNT(CASE WHEN DATEDIFF(year, EMP_DOB, GETDATE()) > @OverAge THEN 1 END) AS [NumberOfEmployeesOver50],
        COUNT(CASE WHEN DATEDIFF(year, EMP_DOB, GETDATE()) < @UnderAge THEN 1 END) AS [NumberOfEmployeesUnder30]
    FROM EMPLOYEE;
END;
GO

EXEC EMP_STATS 50, 30;
GO


-- List of Employees that have mandatory certification expiring in next 6 weeks
DROP PROCEDURE IF EXISTS EMP_EXPIRING_CERT;
GO
CREATE PROCEDURE EMP_EXPIRING_CERT
	@StartDate DATE,
	@EndDate DATE
AS
BEGIN
    SELECT DISTINCT ERT.EMP_ID, E.EMP_FNAME, E.EMP_LNAME, C.CERT_VALID_FOR, C.CERT_ID, C.CERT_NAME
        FROM EMPLOYEE_REGULATORY_TRAINING ERT
        JOIN REGULATORY_TRAINING RT ON ERT.TS_ID = RT.TS_ID
        JOIN CERTIFICATION C ON RT.CERT_ID = C.CERT_ID
		JOIN EMPLOYEE E ON ERT.EMP_ID = E.EMP_ID
    WHERE C.CERT_VALID_FOR BETWEEN @StartDate AND @EndDate
END;
GO

DECLARE @CurrentDate DATE = GETDATE();
DECLARE @SixWeeksLater DATE = DATEADD(WEEK, 6, @CurrentDate);

EXEC EMP_EXPIRING_CERT @StartDate = @CurrentDate, @EndDate = @SixWeeksLater;
GO

-- List of Employees that need updated in-house training
DROP PROCEDURE IF EXISTS EMP_UPDATE_TRAINING;
GO
CREATE PROCEDURE EMP_UPDATE_TRAINING
AS
BEGIN
    SELECT DISTINCT E.EMP_ID, E.EMP_FNAME, E.EMP_LNAME, TS.TS_TYPE, TS.TS_DATE, ERT.EXPIRATION_DATE, ST.SKILL_ID, C.CERT_NAME FROM EMPLOYEE E
        JOIN EMPLOYEE_SKILL_TRAINING EST ON E.EMP_ID = EST.EMP_ID
        JOIN TRAINING_SESSION TS ON EST.TS_ID = TS.TS_ID
        JOIN SKILL_TRAINING ST ON TS.TS_ID = ST.TS_ID
        LEFT JOIN REGULATORY_TRAINING RT ON TS.TS_ID = RT.TS_ID
        LEFT JOIN CERTIFICATION C ON RT.CERT_ID = C.CERT_ID
        JOIN EMPLOYEE_REGULATORY_TRAINING ERT ON E.EMP_ID = ERT.EMP_ID
    WHERE TS.TS_TYPE = 'ST' AND ERT.EXPIRATION_DATE < GETDATE();
END;
GO

EXEC EMP_UPDATE_TRAINING;
GO

-- List of employees who have expired training
DROP PROCEDURE IF EXISTS EMP_EXPIRED_TRAINING;
GO
CREATE PROCEDURE EMP_EXPIRED_TRAINING
AS
BEGIN
    SELECT DISTINCT E.EMP_ID, E.EMP_FNAME, E.EMP_LNAME, ERT.EXPIRATION_DATE, TS.TS_TYPE
    FROM EMPLOYEE E
    INNER JOIN EMPLOYEE_REGULATORY_TRAINING ERT ON E.EMP_ID = ERT.EMP_ID
    INNER JOIN TRAINING_SESSION TS ON ERT.TS_ID = TS.TS_ID
    WHERE ERT.EXPIRATION_DATE < GETDATE();
END;
GO

EXEC EMP_EXPIRED_TRAINING;
GO

-- Num of unallocated uniforms
DROP PROCEDURE IF EXISTS UNALLO_UNIFORMS
GO
CREATE PROCEDURE UNALLO_UNIFORMS
AS
BEGIN
	SELECT INV_QTY
	FROM INVENTORY
	WHERE INV_NAME = 'Uniforms';
END;
GO

EXEC UNALLO_UNIFORMS;
GO
